/*
** $ 身份; 嘞极限.h $
** 极限, 基本类型和其他一些 安装依赖 定义
** 请参见 炉啊.h中的版权声明
*
* 本人所用声母表: a啊 b哔 c西 d迪 e鹅 f弗 g哥 
* h喝 i艾 j鸡 k颗 l嘞 m摸 n恩
* o欧 p匹 q气 r日 s丝 t嚏 
* u由 v微 w屋 x斯 y医 z只
*
* 一些英文单词缩写,我的翻译大多来自;有道词典,谷歌翻译,百度.
* 一些术语实在不好翻译,所以就原封不动.
* 
* 一些特有的表示特有库的术语是无法翻译的 *
* 否则编译器不能识别不能通过,第一版汉化就行不通.
* 
*/

#ifndef 嘞极限_喝
#define 嘞极限_喝


#include <limits.h>
#include <stddef.h>


#include "炉啊.h"

/*
** '炉_内存' 与 '嘞_内存' 是无符号/有符号整数,
*它们足够计数Lua使用的总内存(以字节为单位).
 通常,
 'size_t' 与 'ptrdiff_t' 应该可以工作,但我们使用 'long' 用于16位机器.
*/
#if defined(炉啊艾_内存)		/* { 外部定义? */
typedef 炉啊艾_无符内存 炉_内存;
typedef 炉啊艾_内存 嘞_内存;
#elif 炉啊艾_是否32位整型	/* }{ */
typedef size_t 炉_内存;
typedef ptrdiff_t 嘞_内存;
#else  /* 16位 整型 */	/* }{ */
typedef unsigned long 炉_内存;
typedef long 嘞_内存;
#endif				/* } */

/* 用作小自然的印刻 ( '印刻' 是为字符保留的) */
typedef unsigned char 炉_字节;
typedef signed char 嘞丝_字节;

/* 最大值为 size_t */
#define 最大_大小嚏	((size_t)(~(size_t)0))

/* 炉啊可见的最大大小 (必须是可表示的 在 炉啊_整数 内) */
#define 最大_大小	(sizeof(size_t) < sizeof(炉啊_整数) ? 最大_大小嚏 \
                          : (size_t)(炉啊_最大整数))

#define 最大_炉内存	((炉_内存)(~(炉_内存)0))

#define 最大_嘞内存	((嘞_内存)(最大_炉内存 >> 1))


#define 最大_整型		整型_最大  /* 整型的最大值 */


/*
** log2 对数2 向下取整 最大符号值整数类型 '嚏'.
** (这是, 最大 '恩' 这样 '2^恩' 符合给定的带符号类型.)
*/
#define 对数2最大(嚏)	(sizeof(嚏) * 8 - 2)

/*
** 测试是否为无符号值 是2的幂 (或 是零)
*/
#define 是否幂2(斯)	(((斯) & ((斯) - 1)) == 0)

/* 无结尾字面值串的字符数 \0 */

#define 嘞嘞(斯)   (sizeof(斯)/sizeof(char) - 1)

/*
** 指针到无符号整数的转换;
** 这只用于哈希;
   如果整数不能保存整个指针值,也没有问题
*/
#define 指针到无符号整型(匹)	((unsigned int)((size_t)(匹) & 无符号整型_最大))


/*  '常用实参转换' 的类型 为 炉啊_号码 与 炉啊_整数 */
typedef 炉啊艾_常用实参转换号码 嘞_常用实参转换号码;
typedef 炉啊艾_常用实参转换整型 嘞_常用实参转换整型;

/* 用于内部调试的内部断言 */
#if defined(炉啊_断言)
#define 检查_表达式(西,鹅)		(炉啊_断言(西), (鹅))
/* 避免条件太长导致的问题 */
#define 炉啊_长断言(西)	((西) ? (void)0 : 炉啊_断言(0))
#else
#define 炉啊_断言(西)		((void)0)
#define 检查_表达式(西,鹅)		(鹅)
#define 炉啊_长断言(西)	((void)0)
#endif

/*
** 用于检查 应用程序接口 调用的断言
*/
#if !defined(炉啊艾_应用程序接口检查)
#define 炉啊艾_应用程序接口检查(嘞,鹅)	((void)嘞, 炉啊_断言(鹅))
#endif

#define 应用程序接口_检查(嘞,鹅,消息)	炉啊艾_应用程序接口检查(嘞,(鹅) && 消息)

/* 宏以避免关于未使用变量的警告 */
#if !defined(未使用)
#define 未使用(斯)	((void)(斯))
#endif

/* 类型转换 (在代码中高亮显示一个宏) */
#define 投(嚏, 表达式)	((嚏)(表达式))

#define 投_空的(艾)	投(void, (艾))
#define 投_空的匹(艾)	投(void *, (艾))
#define 投_号(艾)	投(炉啊_号码, (艾))
#define 投_整型(艾)	投(int, (艾))
#define 投_无符整型(艾)	投(unsigned int, (艾))
#define 投_字节(艾)	投(炉_字节, (艾))
#define 投_无符印刻(艾)	投(unsigned char, (艾))
#define 投_印刻(艾)	投(char, (艾))
#define 投_印刻匹(艾)	投(char *, (艾))
#define 投_大小嚏(艾)	投(size_t, (艾))

/* 转换一个有符号的 炉啊_整数 到 炉啊_无符号 */
#if !defined(嘞_投有符到无符)
#define 嘞_投有符到无符(艾)	((炉啊_无符号)(艾))
#endif

/*
** 投 炉啊_无符号 转换为有符号的 炉啊_整数 ;
   这个投不是严格的ISO C ,
   但是双补架构应该可以很好地工作.
*/

#if !defined(嘞_投无符到有符)
#define 嘞_投无符到有符(艾)	((炉啊_整数)(艾))
#endif

/*
** 宏来改进跳转预测 (主要用于错误处理)
*/
#if !defined(可能的)

#if defined(__GNUC__)
#define 可能的(斯)	(__builtin_expect(((斯) != 0), 1))
#define 不可能的(斯)	(__builtin_expect(((斯) != 0), 0))
#else
#define 可能的(斯)	(斯)
#define 不可能的(斯)	(斯)
#endif

#endif

/*
** 不返回类型
*/

#if !defined(嘞_不返)

#if defined(__GNUC__)     /* 一些特有的表示特有库的术语是无法翻译的 */
#define 嘞_不返		void __attribute__((noreturn))
#elif defined(_MSC_VER) && _MSC_VER >= 1200
#define 嘞_不返		void __declspec(noreturn)
#else
#define 嘞_不返		void
#endif

#endif

/*
** 类型用于虚拟机器指令;
** 必须是无符号的(至少)4字节 (看到细节 嘞操作码.h)
*/
#if 炉啊艾_是否32位整型
typedef unsigned int 嘞_无符整型32;
#else
typedef unsigned long 嘞_无符整型32;
#endif

typedef 嘞_无符整型32 指令;

/*
** 短字符串的最大长度, 这是, 内在化的字符串. 
*(不能小于元方法的保留字或标记, 
*因为这些字符串必须内部化;
** #("函数") = 8, #("__新索引") = 10.)
*/
#if !defined(炉啊艾_最大短长度)
#define 炉啊艾_最大短长度	40
#endif

/*
** 串表的初始大小(必须是2的幂)。
   仅 炉啊 核心就注册了大约50个串(保留字 + 元事件键 + 其他一些串)。
   库通常会增加几十个。
*/
#if !defined(最小串表大小)
#define 最小串表大小	128
#endif

/*
** 应用程序接口 中串缓存的大小。
   恩 是集合的数量(最好是素数)
   摸 是每个集合的大小(摸 == 1是直接缓存)。
*/
#if !defined(串缓存_恩)
#define 串缓存_恩		53
#define 串缓存_摸		2
#endif


/* 串缓冲区的最小大小 */
#if !defined(炉啊_最小缓冲)
#define 炉啊_最小缓冲	32
#endif

/*
** 宏,当程序进入 炉啊 内核('炉啊_锁')并离开内核('炉啊_解锁')时执行.
*/
#if !defined(炉啊_锁)
#define 炉啊_锁(嘞)	((void) 0)
#define 炉啊_解锁(嘞)	((void) 0)
#endif

/*
  在 炉啊 函数可以产生结果时执行的宏。
*/
#if !defined(炉啊艾_线程产出)
#define 炉啊艾_线程产出(嘞)	{炉啊_解锁(嘞); 炉啊_锁(嘞);}
#endif

/*
** 当线程被 创建/删除/恢复/产出 时，这些宏允许用户特定的操作。
*/
#if !defined(炉啊艾_用户状态打开)
#define 炉啊艾_用户状态打开(嘞)		((void)嘞)
#endif

#if !defined(炉啊艾_用户状态关闭)
#define 炉啊艾_用户状态关闭(嘞)		((void)嘞)
#endif

#if !defined(炉啊艾_用户状态线程)
#define 炉啊艾_用户状态线程(嘞,嘞1)	((void)嘞)
#endif

#if !defined(炉啊艾_用户状态自由)
#define 炉啊艾_用户状态自由(嘞,嘞1)	((void)嘞)
#endif

#if !defined(炉啊艾_用户状态恢复)
#define 炉啊艾_用户状态恢复(嘞,恩)	((void)嘞)
#endif

#if !defined(炉啊艾_用户状态产出)
#define 炉啊艾_用户状态产出(嘞,恩)	((void)嘞)
#endif

/*
** 炉啊艾_号* 宏定义了对号码的原语操作.
*/

/* 向下取整除法 (已定义于 '向下取整(啊/哔)') */
#if !defined(炉啊艾_号符号除)
#define 炉啊艾_号符号除(嘞,啊,哔)     ((void)嘞, 嘞_向下取整(炉啊艾_号除(嘞,啊,哔)))
#endif

/* 浮点除法 */
#if !defined(炉啊艾_号除)
#define 炉啊艾_号除(嘞,啊,哔)      ((啊)/(哔))
#endif

/*
** 余数; 定义为 '啊 -层(啊/哔)*哔' ; 直接计算
** 使用这个定义有几个问题与舍入错误,
   所以最好使用 '弗模' .
   '弗模' 给出的结果
** '啊 - 截断(啊/哔)*哔'，因此必须在
** '截断(啊/哔) ~= 向下取整(啊/哔)'
  这发生在除法有一个非整数的负结果时; 非整数的结果等于一个非零余数'摸';
  负的结果等于 '啊' ,
  而 '哔' 的符号不同,或者 '摸' 和 '哔' 的符号不同(因为 '弗模' 的结果 '摸' 和 '啊' 的符号相同).
*/
#if !defined(炉啊艾_号余数)
#define 炉啊艾_号余数(嘞,啊,哔,摸)  \
  { (void)嘞; (摸) = 嘞_数学操作(弗模)(啊,哔); \
    if (((摸) > 0) ? (哔) < 0 : ((摸) < 0 && (哔) > 0)) (摸) += (哔); }
#endif

/* 求幂 */
#if !defined(炉啊艾_号幂)
#define 炉啊艾_号幂(嘞,啊,哔)      ((void)嘞, 嘞_数学操作(幂)(啊,哔))
#endif

/* 其他的都是非常标准的操作 */
#if !defined(炉啊艾_号加)
#define 炉啊艾_号加(嘞,啊,哔)      ((啊)+(哔))
#define 炉啊艾_号减(嘞,啊,哔)      ((啊)-(哔))
#define 炉啊艾_号乘(嘞,啊,哔)      ((啊)*(哔))
#define 炉啊艾_号负(嘞,啊)        (-(啊))
#define 炉啊艾_号等于(啊,哔)         ((啊)==(哔))
#define 炉啊艾_号小于(啊,哔)         ((啊)<(哔))
#define 炉啊艾_号小等(啊,哔)         ((啊)<=(哔))
#define 炉啊艾_号大于(啊,哔)         ((啊)>(哔))
#define 炉啊艾_号大等(啊,哔)         ((啊)>=(哔))
#define 炉啊艾_号是否非数(啊)        (!炉啊艾_号等于((啊), (啊)))
#endif

/*
** 宏来控制对栈重新分配的一些硬测试的包含
*/
#if !defined(硬栈测试)
#define 条件移栈(嘞,预,销售点)	((void)0)
#else

/* 重新分配栈保持它的大小 */

#define 条件移栈(嘞,预,销售点)  \
  { int 丝只_ = (嘞)->栈大小; 预; 炉啊迪_重新分配栈((嘞), 丝只_, 0); 销售点; }
#endif

#if !defined(硬内存测试)
#define 条件改变内存(嘞,预,销售点)	((void)0)
#else
#define 条件改变内存(嘞,预,销售点)  \
	{ if (哥(嘞)->垃圾回收正在跑) { 预; 炉啊西_完全垃圾回收(嘞, 0); 销售点; } }
#endif

#endif